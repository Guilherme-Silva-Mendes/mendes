//! C Backend - Generates C code from the Mendes IR
//!
//! This backend generates portable C99 code that can be compiled with
//! any modern C compiler (gcc, clang, MSVC).

use crate::CodeGen;
use mendes_ir::{Module, Function, Instruction, Value, BinaryOp, CompareOp, IrType};
use std::fmt::Write;

/// C code generation backend
#[derive(Debug, Default)]
pub struct CBackend {
    /// Current indentation level
    indent: usize,
}

impl CBackend {
    pub fn new() -> Self {
        Self::default()
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent)
    }

    fn emit_type(&self, ty: &IrType) -> String {
        match ty {
            IrType::Void => "void".to_string(),
            IrType::I64 => "int64_t".to_string(),
            IrType::F64 => "double".to_string(),
            IrType::Bool => "bool".to_string(),
            IrType::String => "mendes_string_t".to_string(),
            IrType::Ptr(inner) => format!("{}*", self.emit_type(inner)),
            IrType::Array(elem, _) => format!("mendes_array_t /* {} */", self.emit_type(elem)),
            IrType::Struct(name) => format!("struct {}", name),
            IrType::Function { .. } => "void*".to_string(), // Function pointer
            IrType::Future(inner) => format!("mendes_future_t /* {} */", self.emit_type(inner)),
            IrType::Tuple(elems) => {
                // In C, tuples are represented as structs
                let type_names: Vec<_> = elems.iter().enumerate()
                    .map(|(i, e)| format!("{} field{}", self.emit_type(e), i))
                    .collect();
                format!("struct {{ {} }}", type_names.join("; "))
            }
            IrType::Range(_inner) => "mendes_range_t".to_string(),
        }
    }

    fn emit_value(&self, value: &Value) -> String {
        match value {
            Value::ConstInt(v) => format!("{}", v),
            Value::ConstFloat(bits) => format!("{:.6}", f64::from_bits(*bits)),
            Value::ConstBool(v) => if *v { "true" } else { "false" }.to_string(),
            Value::ConstString(idx) => format!("__str_{}", idx),
            Value::Local(name) => name.clone(),
            Value::Param(idx) => format!("__arg{}", idx),
            Value::Global(name) => format!("__{}", name),
            Value::Temp(id) => format!("__t{}", id),
            Value::Void => "".to_string(),
        }
    }

    fn emit_binary_op(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
            BinaryOp::Xor => "^",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
        }
    }

    fn emit_compare_op(&self, op: &CompareOp) -> &'static str {
        match op {
            CompareOp::Eq => "==",
            CompareOp::Ne => "!=",
            CompareOp::Lt => "<",
            CompareOp::Le => "<=",
            CompareOp::Gt => ">",
            CompareOp::Ge => ">=",
        }
    }

    fn emit_prelude(&self, output: &mut String) {
        writeln!(output, "/* Generated by Mendes Compiler */").unwrap();
        writeln!(output, "#include <stdint.h>").unwrap();
        writeln!(output, "#include <stdbool.h>").unwrap();
        writeln!(output, "#include <stdlib.h>").unwrap();
        writeln!(output, "#include <string.h>").unwrap();
        writeln!(output, "#include <stdio.h>").unwrap();
        writeln!(output).unwrap();
        writeln!(output, "/* Mendes Runtime Types */").unwrap();
        writeln!(output, "typedef struct {{ char* data; size_t len; }} mendes_string_t;").unwrap();
        writeln!(output, "typedef struct {{ void* data; size_t len; size_t cap; }} mendes_array_t;").unwrap();
        writeln!(output, "typedef struct {{ void* state; int status; }} mendes_future_t;").unwrap();
        writeln!(output, "typedef struct {{ int status; char* body; }} mendes_response_t;").unwrap();
        writeln!(output).unwrap();
        writeln!(output, "/* Runtime Functions */").unwrap();
        writeln!(output, "mendes_string_t mendes_str(const char* s) {{").unwrap();
        writeln!(output, "    mendes_string_t str;").unwrap();
        writeln!(output, "    str.data = (char*)s;").unwrap();
        writeln!(output, "    str.len = strlen(s);").unwrap();
        writeln!(output, "    return str;").unwrap();
        writeln!(output, "}}").unwrap();
        writeln!(output).unwrap();
        writeln!(output, "mendes_string_t mendes_str_concat(mendes_string_t a, mendes_string_t b) {{").unwrap();
        writeln!(output, "    mendes_string_t result;").unwrap();
        writeln!(output, "    result.len = a.len + b.len;").unwrap();
        writeln!(output, "    result.data = malloc(result.len + 1);").unwrap();
        writeln!(output, "    memcpy(result.data, a.data, a.len);").unwrap();
        writeln!(output, "    memcpy(result.data + a.len, b.data, b.len);").unwrap();
        writeln!(output, "    result.data[result.len] = '\\0';").unwrap();
        writeln!(output, "    return result;").unwrap();
        writeln!(output, "}}").unwrap();
        writeln!(output).unwrap();
    }

    fn emit_string_table(&self, module: &Module, output: &mut String) {
        if module.string_table.is_empty() {
            return;
        }

        writeln!(output, "/* String Table */").unwrap();
        for (i, s) in module.string_table.iter().enumerate() {
            // Escape string for C
            let escaped = s.replace('\\', "\\\\")
                          .replace('"', "\\\"")
                          .replace('\n', "\\n")
                          .replace('\r', "\\r")
                          .replace('\t', "\\t");
            writeln!(output, "static const char* __str_{}_data = \"{}\";", i, escaped).unwrap();
            writeln!(output, "static mendes_string_t __str_{} = {{ (char*)__str_{}_data, {} }};", i, i, s.len()).unwrap();
        }
        writeln!(output).unwrap();
    }

    fn emit_structs(&self, module: &Module, output: &mut String) {
        if module.structs.is_empty() {
            return;
        }

        writeln!(output, "/* Struct Definitions */").unwrap();
        for (name, def) in &module.structs {
            writeln!(output, "typedef struct {} {{", name).unwrap();
            for (field_name, field_type) in &def.fields {
                writeln!(output, "    {} {};", self.emit_type(field_type), field_name).unwrap();
            }
            writeln!(output, "}} {};", name).unwrap();
            writeln!(output).unwrap();
        }
    }

    fn emit_function(&self, func: &Function, output: &mut String) {
        // Signature
        let return_type = self.emit_type(&func.return_type);
        let params: Vec<String> = func.params.iter()
            .enumerate()
            .map(|(i, (name, ty))| format!("{} __arg{} /* {} */", self.emit_type(ty), i, name))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        // Async functions get a different signature
        if func.is_async {
            writeln!(output, "/* async */ {} {}({}) {{", return_type, func.name, params_str).unwrap();
        } else {
            writeln!(output, "{} {}({}) {{", return_type, func.name, params_str).unwrap();
        }

        // Local variables
        for (name, ty) in &func.locals {
            writeln!(output, "    {} {};", self.emit_type(ty), name).unwrap();
        }
        if !func.locals.is_empty() {
            writeln!(output).unwrap();
        }

        // Temporary variables used
        let mut temps_used = std::collections::HashSet::new();
        for block in &func.blocks {
            for inst in &block.instructions {
                if let Some(dest) = inst.dest() {
                    temps_used.insert(dest);
                }
            }
        }
        for temp in &temps_used {
            writeln!(output, "    int64_t __t{}; /* temp */", temp).unwrap();
        }
        if !temps_used.is_empty() {
            writeln!(output).unwrap();
        }

        // Blocks
        for block in &func.blocks {
            if block.label != "entry" {
                writeln!(output, "{}:", block.label).unwrap();
            }
            for inst in &block.instructions {
                self.emit_instruction(inst, output);
            }
        }

        writeln!(output, "}}").unwrap();
        writeln!(output).unwrap();
    }

    fn emit_instruction(&self, inst: &Instruction, output: &mut String) {
        let indent = "    ";
        match inst {
            Instruction::Alloca { dest, ty } => {
                writeln!(output, "{}/* {} {} = alloca */", indent, self.emit_type(ty), dest).unwrap();
            }

            Instruction::Store { value, ptr } => {
                writeln!(output, "{}{} = {};", indent, self.emit_value(ptr), self.emit_value(value)).unwrap();
            }

            Instruction::Load { dest, ptr, .. } => {
                writeln!(output, "{}__t{} = {};", indent, dest, self.emit_value(ptr)).unwrap();
            }

            Instruction::Binary { dest, op, left, right } => {
                writeln!(output, "{}__t{} = {} {} {};",
                    indent, dest, self.emit_value(left), self.emit_binary_op(op), self.emit_value(right)).unwrap();
            }

            Instruction::Compare { dest, op, left, right } => {
                writeln!(output, "{}__t{} = {} {} {};",
                    indent, dest, self.emit_value(left), self.emit_compare_op(op), self.emit_value(right)).unwrap();
            }

            Instruction::Not { dest, value } => {
                writeln!(output, "{}__t{} = !{};", indent, dest, self.emit_value(value)).unwrap();
            }

            Instruction::Neg { dest, value } => {
                writeln!(output, "{}__t{} = -{};", indent, dest, self.emit_value(value)).unwrap();
            }

            Instruction::Call { dest, func, args } => {
                let args_str: Vec<String> = args.iter().map(|a| self.emit_value(a)).collect();
                if let Some(d) = dest {
                    writeln!(output, "{}__t{} = {}({});", indent, d, func, args_str.join(", ")).unwrap();
                } else {
                    writeln!(output, "{}{}({});", indent, func, args_str.join(", ")).unwrap();
                }
            }

            Instruction::Return(value) => {
                match value {
                    Value::Void => writeln!(output, "{}return;", indent).unwrap(),
                    Value::ConstString(idx) => {
                        writeln!(output, "{}return __str_{};", indent, idx).unwrap();
                    }
                    _ => writeln!(output, "{}return {};", indent, self.emit_value(value)).unwrap(),
                }
            }

            Instruction::Branch { target } => {
                writeln!(output, "{}goto {};", indent, target).unwrap();
            }

            Instruction::CondBranch { cond, then_label, else_label } => {
                writeln!(output, "{}if ({}) goto {}; else goto {};",
                    indent, self.emit_value(cond), then_label, else_label).unwrap();
            }

            Instruction::Phi { dest, incoming } => {
                writeln!(output, "{}/* phi __t{} = {:?} */", indent, dest, incoming).unwrap();
            }

            Instruction::GetField { dest, ptr, struct_name, field_index, field_name } => {
                writeln!(output, "{}__t{} = ((struct {}*){})->field{};",
                    indent, dest, struct_name, self.emit_value(ptr), field_index).unwrap();
            }

            Instruction::SetField { ptr, struct_name, field_index, field_name, value } => {
                writeln!(output, "{}((struct {}*){})->field{} = {};",
                    indent, struct_name, self.emit_value(ptr), field_index, self.emit_value(value)).unwrap();
            }

            Instruction::GetElement { dest, ptr, index } => {
                writeln!(output, "{}__t{} = ((int64_t*){})[{}];",
                    indent, dest, self.emit_value(ptr), self.emit_value(index)).unwrap();
            }

            Instruction::SetElement { ptr, index, value } => {
                writeln!(output, "{}((int64_t*){})[{}] = {};",
                    indent, self.emit_value(ptr), self.emit_value(index), self.emit_value(value)).unwrap();
            }

            Instruction::Await { dest, future } => {
                writeln!(output, "{}/* await */ __t{} = (int64_t){}.state; /* TODO: async runtime */",
                    indent, dest, self.emit_value(future)).unwrap();
            }

            Instruction::NewStruct { dest, struct_name } => {
                writeln!(output, "{}/* newstruct {} */ __t{} = (int64_t)calloc(1, sizeof(struct {}));",
                    indent, struct_name, dest, struct_name).unwrap();
            }

            Instruction::NewArray { dest, elem_type, size } => {
                writeln!(output, "{}/* newarray */ __t{} = (int64_t)calloc({}, sizeof({}));",
                    indent, dest, self.emit_value(size), self.emit_type(elem_type)).unwrap();
            }

            Instruction::Cast { dest, value, to_type } => {
                writeln!(output, "{}__t{} = ({})({});",
                    indent, dest, self.emit_type(to_type), self.emit_value(value)).unwrap();
            }

            Instruction::Comment(text) => {
                writeln!(output, "{}/* {} */", indent, text).unwrap();
            }
        }
    }

    fn emit_http_routes(&self, module: &Module, output: &mut String) {
        if module.routes.is_empty() {
            return;
        }

        writeln!(output, "/* HTTP Route Table */").unwrap();
        writeln!(output, "typedef struct {{").unwrap();
        writeln!(output, "    const char* method;").unwrap();
        writeln!(output, "    const char* path;").unwrap();
        writeln!(output, "    void* handler;").unwrap();
        writeln!(output, "}} mendes_route_t;").unwrap();
        writeln!(output).unwrap();

        writeln!(output, "static mendes_route_t __routes[] = {{").unwrap();
        for route in &module.routes {
            writeln!(output, "    {{ \"{}\", \"{}\", (void*){} }},",
                route.method, route.path, route.handler).unwrap();
        }
        writeln!(output, "    {{ NULL, NULL, NULL }}").unwrap();
        writeln!(output, "}};").unwrap();
        writeln!(output).unwrap();
    }

    fn emit_main(&self, module: &Module, output: &mut String) {
        writeln!(output, "/* Entry Point */").unwrap();
        writeln!(output, "int main(int argc, char** argv) {{").unwrap();

        if let Some(server) = &module.server {
            writeln!(output, "    printf(\"Mendes Server starting on {}:{}\\n\");",
                server.host, server.port).unwrap();
            writeln!(output, "    printf(\"Routes registered: {}\\n\");", module.routes.len()).unwrap();
            for route in &module.routes {
                writeln!(output, "    printf(\"  {} {}\\n\");", route.method, route.path).unwrap();
            }
            writeln!(output, "    /* TODO: Start HTTP server */").unwrap();
        }

        writeln!(output, "    return 0;").unwrap();
        writeln!(output, "}}").unwrap();
    }
}

impl CodeGen for CBackend {
    type Output = String;

    fn generate(&self, module: &Module) -> String {
        let mut output = String::new();

        // Prelude
        self.emit_prelude(&mut output);

        // String table
        self.emit_string_table(module, &mut output);

        // Struct definitions
        self.emit_structs(module, &mut output);

        // Forward declarations
        writeln!(output, "/* Forward Declarations */").unwrap();
        for func in &module.functions {
            let return_type = self.emit_type(&func.return_type);
            let params: Vec<String> = func.params.iter()
                .map(|(_, ty)| self.emit_type(ty))
                .collect();
            let params_str = if params.is_empty() { "void".to_string() } else { params.join(", ") };
            writeln!(output, "{} {}({});", return_type, func.name, params_str).unwrap();
        }
        writeln!(output).unwrap();

        // HTTP route table
        self.emit_http_routes(module, &mut output);

        // Functions
        for func in &module.functions {
            self.emit_function(func, &mut output);
        }

        // Main function
        self.emit_main(module, &mut output);

        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mendes_ir::{Module, Function, BasicBlock, IrType, Instruction, Value};

    #[test]
    fn test_simple_function() {
        let mut module = Module::new("test");

        let mut func = Function::new("add", IrType::I64, false);
        func.add_param("a", IrType::I64);
        func.add_param("b", IrType::I64);

        let t0 = func.new_temp();
        func.emit(Instruction::Binary {
            dest: t0,
            op: BinaryOp::Add,
            left: Value::Param(0),
            right: Value::Param(1),
        });
        func.emit(Instruction::Return(Value::Temp(t0)));

        module.add_function(func);

        let backend = CBackend::new();
        let code = backend.generate(&module);

        assert!(code.contains("int64_t add("));
        assert!(code.contains("__t0 = __arg0 + __arg1"));
        assert!(code.contains("return __t0"));
    }

    #[test]
    fn test_string_table() {
        let mut module = Module::new("test");
        module.add_string("Hello".to_string());
        module.add_string("World".to_string());

        let backend = CBackend::new();
        let code = backend.generate(&module);

        assert!(code.contains("__str_0_data = \"Hello\""));
        assert!(code.contains("__str_1_data = \"World\""));
    }

    #[test]
    fn test_struct_generation() {
        let mut module = Module::new("test");

        let mut user = mendes_ir::types::StructDef::new("User".to_string());
        user.add_field("id".to_string(), IrType::I64);
        user.add_field("name".to_string(), IrType::String);
        module.add_struct(user);

        let backend = CBackend::new();
        let code = backend.generate(&module);

        assert!(code.contains("typedef struct User"));
        assert!(code.contains("int64_t id"));
        assert!(code.contains("mendes_string_t name"));
    }
}
